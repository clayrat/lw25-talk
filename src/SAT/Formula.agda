module SAT.Formula where

open import Prelude
open import Foundations.Sigma
open import Meta.Effect using (Effect; Bind-Id ; map)
open Variadics _
open import Logic.Discreteness
open import Functions.Embedding
open import System.Everything

open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.Reflects as Reflects
open import Data.Dec
open import Data.Sum
open import Data.Nat
open import Data.Char
open import Data.String
open import Data.Maybe as Maybe
open import Data.List
open import Data.List.Correspondences.Unary.Any

open import Order.Constructions.Minmax
open import Order.Constructions.Nat
open decminmax ‚Ñï-dec-total

open import Level.Bounded
import Induction.Nat.Strong as INS
open import Data.List.NonEmpty as List‚Å∫
open import Data.List.Sized.Interface as SZ

open import LFSet
open import LFSet.Membership

open import Base 0‚Ñì
open import Text.Pretty 80 public renaming (text to textD ; char to charD ; parens to parensD)

open import SAT.Formula0 hiding (Doc ; textD ; charD ; _‚óÜ_ ; _‚óà_ ; sep ; render)
open import SAT.Sem

private variable
  A B : ùí∞
  Œì Œî : LFSet A

data Formula·µ¢ (Œì : LFSet A) : ùí∞ where
  False : Formula·µ¢ Œì
  True  : Formula·µ¢ Œì
  Atom  : (a : A) ‚Üí a ‚àà Œì ‚Üí Formula·µ¢ Œì          -- ideally membership shoud be erased
  Not   : Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì
  And   : Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì
  Or    : Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì
  Imp   : Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì
  Iff   : Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì

wk : {Œì Œî : LFSet A}
   ‚Üí Œì ‚äÜ Œî ‚Üí Formula·µ¢ Œì ‚Üí Formula·µ¢ Œî
wk s  False     = False
wk s  True      = True
wk s (Atom a m) = Atom a (s m)
wk s (Not x)    = Not (wk s x)
wk s (And x y)  = And (wk s x) (wk s y)
wk s (Or x y)   = Or (wk s x) (wk s y)
wk s (Imp x y)  = Imp (wk s x) (wk s y)
wk s (Iff x y)  = Iff (wk s x) (wk s y)

height : {Œì : LFSet A} ‚Üí Formula·µ¢ Œì ‚Üí ‚Ñï
height  False     = 0
height  True      = 0
height (Atom _ _) = 0
height (Not x)    = 1 + height x
height (And x y)  = 1 + max (height x) (height y)
height (Or x y)   = 1 + max (height x) (height y)
height (Imp x y)  = 1 + max (height x) (height y)
height (Iff x y)  = 1 + max (height x) (height y)

height-wk : {Œì Œî : LFSet A}
          ‚Üí {s : Œì ‚äÜ Œî}
          ‚Üí (f : Formula·µ¢ Œì) ‚Üí height (wk s f) Ôºù height f
height-wk  False     = refl
height-wk  True      = refl
height-wk (Atom a m) = refl
height-wk (Not f)    = ap suc (height-wk f)
height-wk (And p q)  = ap¬≤ (Œª x y ‚Üí 1 + max x y) (height-wk p) (height-wk q)
height-wk (Or  p q)  = ap¬≤ (Œª x y ‚Üí 1 + max x y) (height-wk p) (height-wk q)
height-wk (Imp p q)  = ap¬≤ (Œª x y ‚Üí 1 + max x y) (height-wk p) (height-wk q)
height-wk (Iff p q)  = ap¬≤ (Œª x y ‚Üí 1 + max x y) (height-wk p) (height-wk q)

-- sem

eval·µ¢ : {Œì : LFSet A}
      ‚Üí Formula·µ¢ Œì ‚Üí Val A ‚Üí Bool
eval·µ¢  False     v = false
eval·µ¢  True      v = true
eval·µ¢ (Atom a _) v = v a
eval·µ¢ (Not x)    v = not (eval·µ¢ x v)
eval·µ¢ (And x y)  v = eval·µ¢ x v and eval·µ¢ y v
eval·µ¢ (Or x y)   v = eval·µ¢ x v or eval·µ¢ y v
eval·µ¢ (Imp x y)  v = eval·µ¢ x v implies eval·µ¢ y v
eval·µ¢ (Iff x y)  v = eval·µ¢ x v equals eval·µ¢ y v


module Fcode·µ¢ where

  Code : Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì ‚Üí ùí∞
  Code  False       False        = ‚ä§
  Code  True        True         = ‚ä§
  Code (Atom a1 _)   (Atom a2 _) = a1 Ôºù a2
  Code (Not x1)    (Not x2)      = Code x1 x2
  Code (And x1 y1) (And x2 y2)   = Code x1 x2 √ó Code y1 y2
  Code (Or x1 y1)  (Or x2 y2)    = Code x1 x2 √ó Code y1 y2
  Code (Imp x1 y1) (Imp x2 y2)   = Code x1 x2 √ó Code y1 y2
  Code (Iff x1 y1) (Iff x2 y2)   = Code x1 x2 √ó Code y1 y2
  Code  _           _            = ‚ä•

  code-refl : (F : Formula·µ¢ Œì) ‚Üí Code F F
  code-refl  False      = tt
  code-refl  True       = tt
  code-refl (Atom a _)  = refl
  code-refl (Not f)     = code-refl f
  code-refl (And f1 f2) = code-refl f1 , code-refl f2
  code-refl (Or f1 f2)  = code-refl f1 , code-refl f2
  code-refl (Imp f1 f2) = code-refl f1 , code-refl f2
  code-refl (Iff f1 f2) = code-refl f1 , code-refl f2

  encode : {F G : Formula·µ¢ Œì} ‚Üí F Ôºù G ‚Üí Code F G
  encode {F} e = subst (Code F) e (code-refl F)

  decode : {F G : Formula·µ¢ Œì} ‚Üí Code F G ‚Üí F Ôºù G
  decode     {F = False}      {G = False}       tt       = refl
  decode     {F = True}       {G = True}        tt       = refl
  decode     {F = Atom a1 m1} {G = Atom a2 m2}  c        =
    ap¬≤ (Œª x y ‚Üí Atom x y) c (to-path·¥æ (hlevel 1 _ m2))
  decode     {F = Not F}      {G = Not G}       c        =
    ap Not (decode {F = F} c)
  decode {Œì} {F = And F1 F2}  {G = And G1 G2}  (c1 , c2) =
    ap¬≤ {C = Œª _ _ ‚Üí Formula·µ¢ Œì}
        And (decode {F = F1} c1) (decode {F = F2} c2)
  decode {Œì} {F = Or F1 F2}   {G = Or G1 G2}   (c1 , c2) =
    ap¬≤ {C = Œª _ _ ‚Üí Formula·µ¢ Œì}
        Or (decode {F = F1} c1) (decode {F = F2} c2)
  decode {Œì} {F = Imp F1 F2}  {G = Imp G1 G2}  (c1 , c2) =
    ap¬≤ {C = Œª _ _ ‚Üí Formula·µ¢ Œì}
        Imp (decode {F = F1} c1) (decode {F = F2} c2)
  decode {Œì} {F = Iff F1 F2}  {G = Iff G1 G2}  (c1 , c2) =
    ap¬≤ {C = Œª _ _ ‚Üí Formula·µ¢ Œì}
        Iff (decode {F = F1} c1) (decode {F = F2} c2)

Form·µ¢-= : {Œì : LFSet A}
       ‚Üí (A ‚Üí A ‚Üí Bool)
       ‚Üí Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì ‚Üí Bool
Form·µ¢-= e  False        False      = true
Form·µ¢-= e  True         True       = true
Form·µ¢-= e (Atom a1 _)  (Atom a2 _) = e a1 a2
Form·µ¢-= e (Not x1)     (Not x2)    = Form·µ¢-= e x1 x2
Form·µ¢-= e (And x1 y1)  (And x2 y2) = Form·µ¢-= e x1 x2 and Form·µ¢-= e y1 y2
Form·µ¢-= e (Or x1 y1)   (Or x2 y2)  = Form·µ¢-= e x1 x2 and Form·µ¢-= e y1 y2
Form·µ¢-= e (Imp x1 y1)  (Imp x2 y2) = Form·µ¢-= e x1 x2 and Form·µ¢-= e y1 y2
Form·µ¢-= e (Iff x1 y1)  (Iff x2 y2) = Form·µ¢-= e x1 x2 and Form·µ¢-= e y1 y2
Form·µ¢-= e  _            _          = false

instance
  Reflects-Form·µ¢-= : {Œì : LFSet A} {e : A ‚Üí A ‚Üí Bool} ‚¶É r : ‚àÄ {x y} ‚Üí Reflects (x Ôºù y) (e x y) ‚¶Ñ
                     {f g : Formula·µ¢ Œì}
                   ‚Üí Reflects (f Ôºù g) (Form·µ¢-= e f g)
  Reflects-Form·µ¢-=       {f = False}      {g = False}     = of ∏ refl
  Reflects-Form·µ¢-=       {f = False}      {g = True}      = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = False}      {g = Atom a2 _} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = False}      {g = Not x2}    = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = False}      {g = And x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = False}      {g = Or x2 y2}  = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = False}      {g = Imp x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = False}      {g = Iff x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = True}       {g = False}     = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = True}       {g = True}      = of ∏ refl
  Reflects-Form·µ¢-=       {f = True}       {g = Atom a2 _} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = True}       {g = Not x2}    = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = True}       {g = And x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = True}       {g = Or x2 y2}  = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = True}       {g = Imp x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = True}       {g = Iff x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Atom a1 _}  {g = False}     = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Atom a1 _}  {g = True}      = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-= ‚¶É r ‚¶Ñ {f = Atom a1 m1} {g = Atom a2 m2} =
    Reflects.dmap (Œª e ‚Üí ap¬≤ Atom e (to-path·¥æ (hlevel 1 _ m2)))
                  (contra Fcode·µ¢.encode) r
  Reflects-Form·µ¢-=       {f = Atom a1 _}   {g = Not x2}    = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Atom a1 _}   {g = And x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Atom a1 _}   {g = Or x2 y2}  = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Atom a1 _}   {g = Imp x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Atom a1 _}   {g = Iff x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Not x1}    {g = False}     = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Not x1}    {g = True}      = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Not x1}    {g = Atom a2 _}   = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Not x1}    {g = Not x2}    =
    Reflects.dmap (ap Not)
                  (contra (Fcode·µ¢.decode ‚àò Fcode·µ¢.encode))
                  (Reflects-Form·µ¢-= {f = x1} {g = x2})
  Reflects-Form·µ¢-=       {f = Not x1}    {g = And x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Not x1}    {g = Or x2 y2}  = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Not x1}    {g = Imp x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Not x1}    {g = Iff x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = And x1 y1} {g = False}     = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = And x1 y1} {g = True}      = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = And x1 y1} {g = Atom a2 _}   = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = And x1 y1} {g = Not x2}    = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = And x1 y1} {g = And x2 y2} =
    Reflects.dmap ((Œª e1 ‚Üí ap¬≤ And e1) $¬≤_)
                  (contra Œª e ‚Üí let (c1 , c2) = Fcode·µ¢.encode e in
                                Fcode·µ¢.decode c1 , Fcode·µ¢.decode c2
                  )
                  (Reflects-√ó ‚¶É rp = Reflects-Form·µ¢-= {f = x1} {g = x2} ‚¶Ñ
                              ‚¶É rq = Reflects-Form·µ¢-= {f = y1} {g = y2} ‚¶Ñ)
  Reflects-Form·µ¢-=       {f = And x1 y1} {g = Or x2 y2}  = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = And x1 y1} {g = Imp x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = And x1 y1} {g = Iff x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Or x1 y1}  {g = False}     = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Or x1 y1}  {g = True}      = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Or x1 y1}  {g = Atom a2 _}   = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Or x1 y1}  {g = Not x2}    = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Or x1 y1}  {g = And x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Or x1 y1}  {g = Or x2 y2}  =
    Reflects.dmap ((Œª e1 ‚Üí ap¬≤ Or e1) $¬≤_)
                  (contra Œª e ‚Üí let (c1 , c2) = Fcode·µ¢.encode e in
                                Fcode·µ¢.decode c1 , Fcode·µ¢.decode c2
                  )
                  (Reflects-√ó ‚¶É rp = Reflects-Form·µ¢-= {f = x1} {g = x2} ‚¶Ñ
                              ‚¶É rq = Reflects-Form·µ¢-= {f = y1} {g = y2} ‚¶Ñ)
  Reflects-Form·µ¢-=       {f = Or x1 y1}  {g = Imp x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Or x1 y1}  {g = Iff x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Imp x1 y1} {g = False}     = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Imp x1 y1} {g = True}      = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Imp x1 y1} {g = Atom a2 _}   = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Imp x1 y1} {g = Not x2}    = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Imp x1 y1} {g = And x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Imp x1 y1} {g = Or x2 y2}  = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Imp x1 y1} {g = Imp x2 y2} =
    Reflects.dmap ((Œª e1 ‚Üí ap¬≤ Imp e1) $¬≤_)
                  (contra Œª e ‚Üí let (c1 , c2) = Fcode·µ¢.encode e in
                                Fcode·µ¢.decode c1 , Fcode·µ¢.decode c2
                  )
                  (Reflects-√ó ‚¶É rp = Reflects-Form·µ¢-= {f = x1} {g = x2} ‚¶Ñ
                              ‚¶É rq = Reflects-Form·µ¢-= {f = y1} {g = y2} ‚¶Ñ)
  Reflects-Form·µ¢-=       {f = Imp x1 y1} {g = Iff x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Iff x1 y1} {g = False}     = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Iff x1 y1} {g = True}      = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Iff x1 y1} {g = Atom x2 _} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Iff x1 y1} {g = Not x2}    = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Iff x1 y1} {g = And x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Iff x1 y1} {g = Or  x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Iff x1 y1} {g = Imp x2 y2} = of‚Åø Fcode·µ¢.encode
  Reflects-Form·µ¢-=       {f = Iff x1 y1} {g = Iff x2 y2} =
    Reflects.dmap ((Œª e1 ‚Üí ap¬≤ Iff e1) $¬≤_)
                  (contra Œª e ‚Üí let (c1 , c2) = Fcode·µ¢.encode e in
                                Fcode·µ¢.decode c1 , Fcode·µ¢.decode c2
                  )
                  (Reflects-√ó ‚¶É rp = Reflects-Form·µ¢-= {f = x1} {g = x2} ‚¶Ñ
                              ‚¶É rq = Reflects-Form·µ¢-= {f = y1} {g = y2} ‚¶Ñ)
  {-# OVERLAPPABLE Reflects-Form·µ¢-= #-}

  Form·µ¢-is-discrete : {Œì : LFSet A} ‚¶É d : is-discrete A ‚¶Ñ ‚Üí is-discrete (Formula·µ¢ Œì)
  Form·µ¢-is-discrete ‚¶É d ‚¶Ñ {x} {y} .does  = Form·µ¢-= (Œª x y ‚Üí d {x = x} {y = y} .does) x y
  Form·µ¢-is-discrete               .proof = Reflects-Form·µ¢-=

wk-inj : {Œì Œî : LFSet A} {s : Œì ‚äÜ Œî}
       -- not necessary but makes proof more compact by skipping impossible cases
       ‚Üí ‚¶É d : is-discrete A ‚¶Ñ
       ‚Üí Injective (wk s)
wk-inj {Œì} {s} ‚¶É d ‚¶Ñ {x} {y} = aux x y ‚àò true‚Üíso!
  where
  aux : (x y : Formula·µ¢ Œì)
      ‚Üí ‚åû Form·µ¢-= (Œª p q ‚Üí ‚åä d {x = p} {y = q} ‚åã) (wk s x) (wk s y) ‚åü
      ‚Üí x Ôºù y
  aux  False        False       e = refl
  aux  True         True        e = refl
  aux (Atom a1 m1) (Atom a2 m2) e = ap¬≤ Atom (the (a1 Ôºù a2) (so‚Üítrue! e)) (to-path·¥æ (hlevel 1 _ m2))
  aux (Not p1)     (Not p2)     e = ap Not (aux p1 p2 e)
  aux (And p1 q1)  (And p2 q2)  e =
    let e12 = and-so-‚âÉ $ e in
    ap¬≤ {C = Œª _ _ ‚Üí Formula·µ¢ Œì} And (aux p1 p2 (e12 .fst)) (aux q1 q2 (e12 .snd))
  aux (Or p1 q1)   (Or p2 q2)   e =
    let e12 = and-so-‚âÉ $ e in
    ap¬≤ {C = Œª _ _ ‚Üí Formula·µ¢ Œì} Or (aux p1 p2 (e12 .fst)) (aux q1 q2 (e12 .snd))
  aux (Imp p1 q1)  (Imp p2 q2)  e =
    let e12 = and-so-‚âÉ $ e in
    ap¬≤ {C = Œª _ _ ‚Üí Formula·µ¢ Œì} Imp (aux p1 p2 (e12 .fst)) (aux q1 q2 (e12 .snd))
  aux (Iff p1 q1)  (Iff p2 q2)  e =
    let e12 = and-so-‚âÉ $ e in
    ap¬≤ {C = Œª _ _ ‚Üí Formula·µ¢ Œì} Iff (aux p1 p2 (e12 .fst)) (aux q1 q2 (e12 .snd))

elim-formula·µ¢
  : (P : (Œì : LFSet A) ‚Üí Formula·µ¢ Œì ‚Üí ùí∞)
  ‚Üí ({Œì : LFSet A} ‚Üí P Œì False)
  ‚Üí ({Œì : LFSet A} ‚Üí P Œì True)
  ‚Üí (‚àÄ {Œì : LFSet A} a (a‚àà : a ‚àà Œì) ‚Üí P Œì (Atom a a‚àà))
  ‚Üí (‚àÄ {Œì : LFSet A} {x} ‚Üí P Œì x ‚Üí P Œì (Not x))
  ‚Üí (‚àÄ {Œì : LFSet A} {x y} ‚Üí P Œì x ‚Üí P Œì y ‚Üí P Œì (And x y))
  ‚Üí (‚àÄ {Œì : LFSet A} {x y} ‚Üí P Œì x ‚Üí P Œì y ‚Üí P Œì (Or x y))
  ‚Üí (‚àÄ {Œì : LFSet A} {x y} ‚Üí P Œì x ‚Üí P Œì y ‚Üí P Œì (Imp x y))
  ‚Üí (‚àÄ {Œì : LFSet A} {x y} ‚Üí P Œì x ‚Üí P Œì y ‚Üí P Œì (Iff x y))
  ‚Üí {Œì : LFSet A} ‚Üí ‚àÄ x ‚Üí P Œì x
elim-formula·µ¢ P pf pt pa pn pand por pimp piff  False      = pf
elim-formula·µ¢ P pf pt pa pn pand por pimp piff  True       = pt
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Atom a a‚àà) = pa a a‚àà
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Not x)     =
  pn (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (And x y)   =
  pand (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
       (elim-formula·µ¢ P pf pt pa pn pand por pimp piff y)
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Or x y)    =
  por (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
      (elim-formula·µ¢ P pf pt pa pn pand por pimp piff y)
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Imp x y)   =
  pimp (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
       (elim-formula·µ¢ P pf pt pa pn pand por pimp piff y)
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Iff x y)   =
  piff (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
       (elim-formula·µ¢ P pf pt pa pn pand por pimp piff y)

{-
elim-formula·µ¢
  : {Œì : LFSet A} (P : Formula·µ¢ Œì ‚Üí ùí∞)
  ‚Üí P False
  ‚Üí P True
  ‚Üí (‚àÄ a (a‚àà : a ‚àà Œì) ‚Üí P (Atom a a‚àà))
  ‚Üí (‚àÄ {x} ‚Üí P x ‚Üí P (Not x))
  ‚Üí (‚àÄ {x y} ‚Üí P x ‚Üí P y ‚Üí P (And x y))
  ‚Üí (‚àÄ {x y} ‚Üí P x ‚Üí P y ‚Üí P (Or x y))
  ‚Üí (‚àÄ {x y} ‚Üí P x ‚Üí P y ‚Üí P (Imp x y))
  ‚Üí (‚àÄ {x y} ‚Üí P x ‚Üí P y ‚Üí P (Iff x y))
  ‚Üí ‚àÄ x ‚Üí P x
elim-formula·µ¢ P pf pt pa pn pand por pimp piff  False      = pf
elim-formula·µ¢ P pf pt pa pn pand por pimp piff  True       = pt
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Atom a a‚àà) = pa a a‚àà
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Not x)     =
  pn (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (And x y)   =
  pand (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
       (elim-formula·µ¢ P pf pt pa pn pand por pimp piff y)
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Or x y)    =
  por (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
      (elim-formula·µ¢ P pf pt pa pn pand por pimp piff y)
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Imp x y)   =
  pimp (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
       (elim-formula·µ¢ P pf pt pa pn pand por pimp piff y)
elim-formula·µ¢ P pf pt pa pn pand por pimp piff (Iff x y)   =
  piff (elim-formula·µ¢ P pf pt pa pn pand por pimp piff x)
       (elim-formula·µ¢ P pf pt pa pn pand por pimp piff y)
-}

-- atom-set

{-
atomsr‚Çõ : Formula A ‚Üí LFSet A
atomsr‚Çõ  False    = []
atomsr‚Çõ  True     = []
atomsr‚Çõ (Atom x)  = x ‚à∑ []
atomsr‚Çõ (Not x)   = atomsr‚Çõ x
atomsr‚Çõ (And x y) = atomsr‚Çõ x ‚à™‚à∑ atomsr‚Çõ y
atomsr‚Çõ (Or x y)  = atomsr‚Çõ x ‚à™‚à∑ atomsr‚Çõ y
atomsr‚Çõ (Imp x y) = atomsr‚Çõ x ‚à™‚à∑ atomsr‚Çõ y
atomsr‚Çõ (Iff x y) = atomsr‚Çõ x ‚à™‚à∑ atomsr‚Çõ y
-}

chk : (f : Formula A) ‚Üí Formula·µ¢ (atoms‚Çõ f)
chk  False    = False
chk  True     = True
chk (Atom a)  = Atom a (here‚Çõ refl)
chk (Not x)   = Not (chk x)
chk (And x y) =
  And (wk ‚àà‚Çõ-‚à™‚à∑‚Üêl (chk x)) (wk (‚àà‚Çõ-‚à™‚à∑‚Üêr {s‚ÇÅ = atoms‚Çõ x}) (chk y))
chk (Or x y)  =
  Or (wk ‚àà‚Çõ-‚à™‚à∑‚Üêl (chk x)) (wk (‚àà‚Çõ-‚à™‚à∑‚Üêr {s‚ÇÅ = atoms‚Çõ x}) (chk y))
chk (Imp x y) =
  Imp (wk ‚àà‚Çõ-‚à™‚à∑‚Üêl (chk x)) (wk (‚àà‚Çõ-‚à™‚à∑‚Üêr {s‚ÇÅ = atoms‚Çõ x}) (chk y))
chk (Iff x y) =
  Iff (wk ‚àà‚Çõ-‚à™‚à∑‚Üêl (chk x)) (wk (‚àà‚Çõ-‚à™‚à∑‚Üêr {s‚ÇÅ = atoms‚Çõ x}) (chk y))

ers : {Œì : LFSet A}
    ‚Üí Formula·µ¢ Œì ‚Üí Formula A
ers  False     = False
ers  True      = True
ers (Atom a _) = Atom a
ers (Not x)    = Not (ers x)
ers (And x y)  = And (ers x) (ers y)
ers (Or x y)   = Or (ers x) (ers y)
ers (Imp x y)  = Imp (ers x) (ers y)
ers (Iff x y)  = Iff (ers x) (ers y)

on-atoms·µ¢ : {Œì Œî : LFSet A}
         ‚Üí ({Œì : LFSet A} ‚Üí (a : A) ‚Üí a ‚àà Œì ‚Üí Formula·µ¢ Œî) ‚Üí Formula·µ¢ Œì ‚Üí Formula·µ¢ Œî
on-atoms·µ¢ {Œì} {Œî} f =
 elim-formula·µ¢ (Œª _ _ ‚Üí Formula·µ¢ Œî)
   False True f
   Not And Or Imp Iff

{-
on-atoms·µ¢ f  False    = False
on-atoms·µ¢ f  True     = True
on-atoms·µ¢ f (Atom a m) = f a
on-atoms·µ¢ f (Not x)   = Not (on-atoms·µ¢ f x)
on-atoms·µ¢ f (And x y) = And (on-atoms·µ¢ f x) (on-atoms·µ¢ f y)
on-atoms·µ¢ f (Or x y)  = Or (on-atoms·µ¢ f x) (on-atoms·µ¢ f y)
on-atoms·µ¢ f (Imp x y) = Imp (on-atoms·µ¢ f x) (on-atoms·µ¢ f y)
on-atoms·µ¢ f (Iff x y) = Iff (on-atoms·µ¢ f x) (on-atoms·µ¢ f y)
-}

over-atoms·µ¢ : {Œì : LFSet A}
           ‚Üí (A ‚Üí B ‚Üí B) ‚Üí Formula·µ¢ Œì ‚Üí B ‚Üí B
over-atoms·µ¢ {B} f =
 elim-formula·µ¢ (Œª _ _ ‚Üí B ‚Üí B)
   id id (Œª a _ ‚Üí f a)
   id
   (Œª px py ‚Üí px ‚àò py)
   (Œª px py ‚Üí px ‚àò py)
   (Œª px py ‚Üí px ‚àò py)
   (Œª px py ‚Üí px ‚àò py)

{-
over-atoms·µ¢ f  False    b = b
over-atoms·µ¢ f  True     b = b
over-atoms·µ¢ f (Atom a m)  b = f a b
over-atoms·µ¢ f (Not x)   b = over-atoms·µ¢ f x b
over-atoms·µ¢ f (And x y) b = over-atoms·µ¢ f x (over-atoms·µ¢ f y b)
over-atoms·µ¢ f (Or x y)  b = over-atoms·µ¢ f x (over-atoms·µ¢ f y b)
over-atoms·µ¢ f (Imp x y) b = over-atoms·µ¢ f x (over-atoms·µ¢ f y b)
over-atoms·µ¢ f (Iff x y) b = over-atoms·µ¢ f x (over-atoms·µ¢ f y b)
-}

atom-list·µ¢ : {Œì : LFSet A}
           ‚Üí (A ‚Üí List B) ‚Üí Formula·µ¢ Œì ‚Üí List B
atom-list·µ¢ f fm = over-atoms·µ¢ (Œª h ‚Üí f h ++_) fm []

atoms-list·µ¢ : {Œì : LFSet A}
            ‚Üí Formula·µ¢ Œì ‚Üí List A
atoms-list·µ¢ = atom-list·µ¢ (_‚à∑ [])

atom-union·µ¢ : {Œì : LFSet A}
            ‚Üí ‚¶É d : is-discrete B ‚¶Ñ
            ‚Üí (A ‚Üí List B) ‚Üí Formula·µ¢ Œì ‚Üí List B
atom-union·µ¢ f fm = nub _=?_ $ atom-list·µ¢ f fm

atoms·µ¢ : {Œì : LFSet A}
       ‚Üí ‚¶É d : is-discrete A ‚¶Ñ
       ‚Üí Formula·µ¢ Œì ‚Üí List A
atoms·µ¢ f = nub _=?_ $ atoms-list·µ¢ f

atoms·µ¢-‚äÜ : {Œì : LFSet A}
         ‚Üí ‚¶É d : is-discrete A ‚¶Ñ
         ‚Üí {f : Formula·µ¢ Œì}
         ‚Üí atoms-list·µ¢ f ‚äÜ Œì
atoms·µ¢-‚äÜ {A} {f} =
  elim-formula·µ¢ (Œª g q ‚Üí (zs : List A) ‚Üí zs ‚äÜ g ‚Üí over-atoms·µ¢ _‚à∑_ q zs ‚äÜ g)
     (Œª zs ‚Üí id)
     (Œª zs ‚Üí id)
     (Œª {Œì} a a‚àà zs zs‚äÜ ‚Üí
         [ (Œª e ‚Üí subst (_‚àà Œì) (e ‚Åª¬π) a‚àà)
         , zs‚äÜ ]·µ§ ‚àò any-uncons)
     (Œª ih zs zs‚äÜ ‚Üí ih zs zs‚äÜ)
     (Œª {Œì} {x} {y} ihl ihr zs zs‚äÜ ‚Üí
         ihl (over-atoms·µ¢ _‚à∑_ y zs) (ihr zs zs‚äÜ))
     (Œª {Œì} {x} {y} ihl ihr zs zs‚äÜ ‚Üí
         ihl (over-atoms·µ¢ _‚à∑_ y zs) (ihr zs zs‚äÜ))
     (Œª {Œì} {x} {y} ihl ihr zs zs‚äÜ ‚Üí
         ihl (over-atoms·µ¢ _‚à∑_ y zs) (ihr zs zs‚äÜ))
     (Œª {Œì} {x} {y} ihl ihr zs zs‚äÜ ‚Üí
         ihl (over-atoms·µ¢ _‚à∑_ y zs) (ihr zs zs‚äÜ))
     f
     [] false!
{-
atoms·µ¢-‚äÜ {f = False}               = false!
atoms·µ¢-‚äÜ {f = True}                = false!
atoms·µ¢-‚äÜ {Œì} {f = Atom a m} {x = z} z‚àà =
  subst (_‚àà Œì) ([ _‚Åª¬π , false! ]·µ§ (any-uncons z‚àà)) m
atoms·µ¢-‚äÜ {f = Not x}    {x = z} z‚àà = atoms·µ¢-‚äÜ {f = x} z‚àà
atoms·µ¢-‚äÜ {f = And x y}  {x = z} z‚àà =
  let ih1 = atoms·µ¢-‚äÜ {f = y}
      ih2 = atoms·µ¢-‚äÜ {f = x}
    in
  {!ih2 ?!}
atoms·µ¢-‚äÜ {f = Or x y}   {x = z} z‚àà = {!!}
atoms·µ¢-‚äÜ {f = Imp x y}  {x = z} z‚àà = {!!}
atoms·µ¢-‚äÜ {f = Iff x y}  {x = z} z‚àà = {!!}
-}

Ctx : ùí∞
Ctx = LFSet Var


-- printer

prettyForm·µ¢ : {Œì : Ctx}
            ‚Üí ‚Ñï ‚Üí Formula·µ¢ Œì ‚Üí Doc
prettyForm·µ¢ p False      = textD "false"
prettyForm·µ¢ p True       = textD "true"
prettyForm·µ¢ p (Atom v _) = textD v
prettyForm·µ¢ p (Not x)    = brk (10 <? p) $ charD '¬¨' ‚óÜ prettyForm·µ¢ 11 x
prettyForm·µ¢ p (And x y)  = brk (8 <? p) $ sep $ (prettyForm·µ¢ 9 x ‚óà charD '‚àß') ‚à∑ prettyForm·µ¢ 8 y ‚à∑ []
prettyForm·µ¢ p (Or x y)   = brk (6 <? p) $ sep $ (prettyForm·µ¢ 7 x ‚óà charD '‚à®') ‚à∑ prettyForm·µ¢ 6 y ‚à∑ []
prettyForm·µ¢ p (Imp x y)  = brk (4 <? p) $ sep $ (prettyForm·µ¢ 5 x ‚óà charD '‚áí') ‚à∑ prettyForm·µ¢ 4 y ‚à∑ []
prettyForm·µ¢ p (Iff x y)  = brk (2 <? p) $ sep $ (prettyForm·µ¢ 3 x ‚óà charD '‚áî') ‚à∑ prettyForm·µ¢ 2 y ‚à∑ []

prettyF·µ¢ : {Œì : Ctx}
         ‚Üí Formula·µ¢ Œì ‚Üí String
prettyF·µ¢ = render ‚àò prettyForm·µ¢ 0

-- TODO generalize?

ppF·µ¢ : ({Œì : Ctx} ‚Üí Formula·µ¢ Œì ‚Üí Formula·µ¢ Œì) ‚Üí String ‚Üí String
ppF·µ¢ f s =
  Maybe.rec
    "parse error"
    (prettyF·µ¢ ‚àò f ‚àò chk)
    (parseForm s)

ppFŒ£·µ¢ : ({Œì : Ctx} ‚Üí Formula·µ¢ Œì ‚Üí Œ£[ Œî Íûâ Ctx ] (Formula·µ¢ (Œî ‚à™‚à∑ Œì))) ‚Üí String ‚Üí String
ppFŒ£·µ¢ f s =
  Maybe.rec
    "parse error"
    -- TODO print new vars for debug too?
    (prettyF·µ¢ ‚àò snd ‚àò f ‚àò chk)
    (parseForm s)

ppFB·µ¢ : ({Œì : Ctx} ‚Üí Formula·µ¢ Œì ‚Üí Bool) ‚Üí Formula Var ‚Üí String
ppFB·µ¢ f = Prelude.show ‚àò f ‚àò chk

-- tests

{-
ctx1 : LFSet String
ctx1 = "p" ‚à∑ "q" ‚à∑ "r" ‚à∑ []

f1 : Formula·µ¢ ctx1
f1 = Imp (Or (Atom "p" (here‚Çõ refl))
             (Atom "q" (there‚Çõ $ here‚Çõ refl)))
         (Atom "r" (there‚Çõ $ there‚Çõ $ here‚Çõ refl))

_ : "p \\/ q => r" ‚ààF
_ = f1 !

_ : prettyF f1 Ôºù "p ‚à® q ‚áí r"
_ = refl

f2 : Form
f2 = Iff (Imp (Atom "p") (Atom "q"))
         (Or (And (Atom "r") (Atom "s"))
             (Iff (Atom "t")
                  (And (Not (Not (Atom "u")))
                       (Atom "v"))))

_ : "p => q <=> r /\\ s \\/ (t <=> ~ ~u /\\ v)" ‚ààF
_ = f2 !

_ : prettyF f2 Ôºù "p ‚áí q ‚áî r ‚àß s ‚à® (t ‚áî ¬¨(¬¨u) ‚àß v)"
_ = refl

main : Main
main = run $ do
  put-str-ln "f1"
  put-str-ln $ prettyF f1
  put-str-ln "f2"
  put-str-ln $ prettyF f2
  put-str-ln "f2‚àßf2"
  put-str-ln $ prettyF (And f2 f2)
  put-str-ln "(f2‚à®f2)‚àßf2"
  put-str-ln $ prettyF (And (Or f2 f2) f2)
-}
